前端项目编码规范与模块化项目架构文档
1. 项目架构核心思想
本项目采用“基于功能模块”的架构思想。项目的核心目标是构建一个高可维护、可扩展的前端应用。
领域驱动设计 (DDD)：将业务功能划分为明确的“领域”或“功能模块”（features）。
关注点分离 (SoC)：每个模块内部按技术类型（组件、API、Store 等）划分目录，但在模块外部，所有与该功能相关的代码都归属于同一个顶层目录。
高内聚、低耦合：模块内部代码紧密相关（高内聚），模块之间通过明确定义的接口（index.ts 导出）进行通信，减少直接依赖（低耦合）。
2. 目录结构规范
2.1 根目录结构
/
├── node_modules/
├── public/
├── src/ # 源码目录
│   ├── assets/ # 静态资源（图片、字体、全局 SCSS 变量等）
│   ├── components/ # 全局通用组件（非业务相关，如按钮、布局组件）
│   ├── composables/ # 全局通用组合式函数
│   ├── constants/ # 全局常量
│   ├── features/ # ★ 核心业务功能模块目录
│   ├── layouts/ # 全局布局组件
│   ├── plugins/ # Vite 插件、第三方库初始化
│   ├── router/ # 路由配置
│   ├── stores/ # 全局 Pinia Store（非模块特有）
│   ├── styles/ # 全局样式文件（Reset CSS、通用 SCSS）
│   ├── types/ # 全局 TypeScript 类型定义
│   ├── utils/ # 全局工具函数
│   ├── views/ # 页面级组件（通常是 features 模块组件的容器）
│   ├── App.vue # 应用根组件
│   ├── env.d.ts # 全局 TS 声明文件
│   └── main.ts # 应用入口文件
├── .eslintrc.cjs # ESLint 配置
├── .prettierrc.cjs # Prettier 配置
├── index.html
├── package.json
├── tsconfig.json
├── vite.config.ts # Vite 配置
└── README.md
2.2 功能模块目录 (src/features/{feature-name}/)
这是本架构的核心。每个功能模块都遵循此结构：
src/features/{feature-name}/
├── api/ # API 调用和接口定义
│   ├── {feature}-api.ts # Axios 服务实例、接口请求函数
│   └── types.ts # 接口请求/响应的 TypeScript 类型
├── components/ # 模块内部使用的私有组件
├── composables/ # 模块内部专用的组合式函数
├── stores/ # 模块内部专用的状态管理
│   └── {feature}Store.ts # Pinia Store 定义
├── types/ # 模块特有的 TS 类型（非 API 相关）
├── utils/ # 模块特有的工具函数
├── constants/ # 模块特有的常量
├── __tests__/ # 单元测试文件
└── index.ts # 模块公共出口（重要）
index.ts 的作用： 它是模块的公共接口。外部模块只能通过导入 {feature-name}/index.ts 来使用此模块暴露的功能（如 Store 实例、特定的 Composable 或类型），严禁直接从子目录深处导入代码。
3. 技术栈使用规范
3.1 Vue 3 & <script setup lang="ts">
统一风格：所有 .vue 文件必须使用 <script setup lang="ts"> 语法糖，推荐使用 Composition API。
Props 定义：使用 defineProps，结合 TypeScript 接口：
vue
<script setup lang="ts">
interface Props {
  title: string;
  isActive?: boolean;
}
const props = defineProps<Props>();
</script>
请谨慎使用此类代码。

事件定义：使用 defineEmits：
vue
<script setup lang="ts">
const emit = defineEmits(['update:modelValue', 'change']);
</script>
请谨慎使用此类代码。

3.2 TypeScript (TS)
严格模式：启用严格的 tsconfig.json 配置。
类型优先：优先使用接口（Interface）定义复杂类型和 API 契约，使用类型别名（Type Alias）定义简单的联合类型或基本类型。
类型文件：全局类型放在 src/types/ 或 src/env.d.ts；模块特有类型放在 src/features/{feature}/types/。API 相关类型必须放在对应的 src/features/{feature}/api/types.ts。
3.3 Pinia
模块化 Store：功能相关的 Store 必须定义在 src/features/{feature}/stores/ 中。
使用 Store：在组件中使用 storeToRefs 解构响应式数据：
ts
import { useUserStore } from '@/features/user/stores/userStore';
import { storeToRefs } from 'pinia';

const userStore = useUserStore();
const { userName, isLoggedIn } = storeToRefs(userStore);
请谨慎使用此类代码。

3.4 Axios & API 管理
封装：在 src/features/{feature}/api/{feature}-api.ts 中封装 API 请求。
实例：可以创建特定的 Axios 实例（例如针对不同微服务的 baseURL）。
拦截器：全局请求拦截器（如添加 Auth Header）在全局工具类中统一配置。
ts
// src/features/user/api/user-api.ts
import request from '@/utils/request'; // 统一封装的 axios 实例
import type { UserInfoResponse } from './types';

export function getUserInfo(userId: string) {
  return request.get<UserInfoResponse>(`/users/${userId}`);
}
请谨慎使用此类代码。

3.5 SCSS
BEM 命名：推荐使用 BEM（Block Element Modifier）命名法管理 CSS 类名，避免样式冲突。
变量与 Mixin：全局 SCSS 变量和 Mixin 统一放在 src/styles/ 或 src/assets/styles/ 中，并在 vite.config.ts 中自动引入。
Scoped 样式：在 .vue 文件中使用 <style scoped lang="scss"> 限制组件样式作用域。
4. 编码风格与工具
4.1 代码格式化与 Linting
ESLint：使用 ESLint 强制执行编码规范，结合 Vue 3 和 TypeScript 规则集。
Prettier：使用 Prettier 进行代码自动格式化，保持全项目代码风格一致。
Git Hooks：配置 Husky 和 lint-staged，在提交（commit）前自动运行 Lint 和 Prettier 检查。
4.2 命名约定
类型	命名规范	示例
组件	PascalCase（大驼峰）	UserProfileCard.vue
文件/目录	kebab-case（短横线连接）	user-api.ts, components/
变量/函数	camelCase（小驼峰）	userName, calculateTotal()
Interface	PascalCase，加 I 前缀（可选）	IUser 或 User
常量	SCREAMING_SNAKE_CASE	API_TIMEOUT
5. 开发流程与协作
新建功能：在 src/features/ 下创建新的功能目录（例如 product-detail）。
内部开发：在模块内部完成所有相关开发工作（Store、API、Components）。
暴露接口：通过 src/features/product-detail/index.ts 暴露所需的功能。
页面集成：在 src/views/ProductDetailPage.vue 中，从 features/product-detail 导入功能并使用。
单元测试：在 __tests__ 目录编写测试用例，确保模块的稳定性。